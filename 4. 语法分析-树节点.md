# 语法分析-树节点

> **在〈3. 词法分析.md〉中可以知道，连续调用`Scanner`类的`nextToken()`方法就可以得到整个Java源代码的Token序列，而语法分析就是根据Token序列构造抽象语法树的过程。**
>
> **语法树中的每一个节点都代表了Jaa源代码中的一个语法结构，如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。**
>
> **在Javac中，每个语法树节点都对应着一个具体的实现类。**
>
> **这些节点可以分为3类：**
>
> + ***定义及声明，如编译单元的定义、方法定义和导入声明等***
> + ***语句，如if语句、while语句等***
> + ***表达式，如两个数值相加的表达式***

> **定义及声明的实现类继承了`com.sun.tools.javac.tree.JCTree`抽象类。**
>
> **语句的实现类继承了`com.sun.tools.javac.tree.JCTree.JCStatement`抽象类，这个抽象类也继承了`JCTree`类。**
>
> **表达式继承了`com.sun.tools.javac.tree.JCTree.JCExpression`抽象类，它也继承了`JCTree`类**
>
> ***每个具体的实现类都定义了对应的接口实现，这些接口定义在`com.sun.source.tree`包路径下，实现类都以静态内部类的形式定义在`JCTree`类中。***
>
> <img src="./assets/JCTree JCStatement 与 JCExpression的继承关系.png" style="zoom:80%;" />
>
> > **Javac抽象语法树上每个节点的实现类都直接或间接继承了抽象类`JCTree`，同时也实现了对应的接口。如`JCXXX`实现类实现了`xxxTree`接口，而`xxxTree`接口与`JCTree`又同时实现了`Tree`接口。**

> ***相关接口、类实现说明***
>
> 1. **com.sun.source.tree.Tree**
>
>     > **`com.sun.source.tree`包下还定义了其它直接或间接继承自Tree接口的其它接口**
>
>     ```java
>     public interface Tree { //定义的通用接口方法
>         Kind getKind();
>         <R,D> R accept(TreeVisitor<R,D> visitor, D data);
>         
>         public enum Kind { //内部类 Kind
>             ANNOTATION(AnnotationTree.class),
>             ARRAY_ACCESS(ArrayAccessTree.class),
>             //... 后面还有一堆枚举值
>             
>             Kind(Class<? extends Tree> intf) {
>                 associatedInterface = intf;
>             }
>     
>             public Class<? extends Tree> asInterface() {
>                 return associatedInterface;
>             }
>     
>             private final Class<? extends Tree> associatedInterface;
>         }
>     }
>     ```
>
> 2. **comsun.source.tree.JCTree抽象类**
>
>     ```java
>     public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
>         //--- 定义的抽象方法
>         public abstract void accept(Visitor v);
>         public abstract <R,D> R accept(TreeVisitor<R,D> v, D d);
>         public abstract int getTag(); //获取类型tag值, Tree接口中定义了获取Kind的方法, 有啥区别??
>     
>         //--- 下面定义了不同的可能的Tag值, 用于getTag()方法返回; 从TOPLEVEL开始依次比前一个全局变量值+1
>         public static final int  TOPLEVEL = 1;
>         public static final int IMPORT = TOPLEVEL + 1;
>         public static final int CLASSDEF = IMPORT + 1;
>         public static final int METHODDEF = CLASSDEF + 1;
>         public static final int VARDEF = METHODDEF + 1;
>         public static final int SKIP = VARDEF + 1;
>         public static final int BLOCK = SKIP + 1;
>         public static final int DOLOOP = BLOCK + 1;
>         public static final int WHILELOOP = DOLOOP + 1;
>         public static final int FORLOOP = WHILELOOP + 1;
>         public static final int FOREACHLOOP = FORLOOP + 1;
>         public static final int LABELLED = FOREACHLOOP + 1;
>         //... 下面一堆其它静态Tag值, 略
>     
>         //The offset between assignment operators and normal operators.
>         public static final int ASGOffset = BITOR_ASG - BITOR;
>     
>     	//--- 成员变量
>         public int pos; //本节点对应的在源文件/源代码中的偏移量
>         public Type type;
>     
>         public DiagnosticPosition pos() {
>             return this;
>         }
>         public int getStartPosition() {
>             return TreeInfo.getStartPos(this);
>         }
>         public int getEndPosition(Map<JCTree, Integer> endPosTable) {
>             return TreeInfo.getEndPos(this, endPosTable);
>         }
>     }
>     ```
>
>     

## 1. 定义及声明

### 1.1 JCCompilationUnit类

>  **每个编译单元(Compilation Unit)都是一个`JCCompilationUnit`对象。一般而言，一个Java源文件对应一个编译单元，如果一个Java源文件中定义了多个类，则`这些类也属于同一个编译单元`。`JCCompilationUnit对象是抽象语法树顶层的树节点，或者说是根节点`**

> **一个编译单元由三部分组成：包声明、导入声明、类型声明。**

```java
//com.sun.tools.javac.tree.JCTree.JCOmpilationUnit内部类    
public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
        public List<JCAnnotation> packageAnnotations; //包注解
        public JCExpression pid; //包声明
        public List<JCTree> defs; //导入声明和类型声明, 保存在defs中的类型一定是顶层类或顶层接口,即非嵌套类型
        public JavaFileObject sourcefile;
        public PackageSymbol packge;
        public ImportScope namedImportScope;
        public StarImportScope starImportScope;
        public long flags;
        public Position.LineMap lineMap = null;
        public Map<JCTree, String> docComments = null;
        public Map<JCTree, Integer> endPositions = null;
}
```

### 1.2 JCImport类

> **每个导入声明(Import Declaration)都是一个`JCImport`对象**
>
> **导入声明有四种类型：**
>
> 1. **import Class;**
> 2. **import Class.\***
> 3. **import static StaticClass;**
> 4. **import static StaticClass.\***

```java
public static class JCImport extends JCTree implements ImportTree {
        public boolean staticImport; //是否为静态导入声明, "import static"时为true
        public JCTree qualid; //保存具体声明的内容
}
```

### 1.3 JCClassDecl类

> **每个类型声明(Class Declaration)或者说类型定义都是一个`JCClassDecl`对象，包括接口、类、以及作为特殊接口的注解类和作为特殊类的枚举类**

```java
public static class JCClassDecl extends JCStatement implements ClassTree {
        public JCModifiers mods; //区分接口和类, 同时保存类/接口的修饰符
        public Name name;
        public List<JCTypeParameter> typarams; //保存类型上声明的多个类型参数
        public JCExpression extending;
        public List<JCExpression> implementing;
        public List<JCTree> defs; //保存类型内部的一些成员, 包括成员变量和方法等
        public ClassSymbol sym;
}
```

### 1.4 JCModifiers类

> **`JCModifiers`类用来表示修饰符，如public、abstract和native等，还能表示注解。**

```java
public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
        public long flags; //保存修饰符, 64位中具体哪个位代表哪个修饰符,可参考Flags类
        public List<JCAnnotation> annotations; //保存注解信息
}
```

### 1.5 JCTypeParameter类

> **每个形式类型参数都是一个`JCTypeParameter`对象。**

```java
    public static class JCTypeParameter extends JCTree implements TypeParameterTree {
        public Name name; //类型参数中类型变量的名称
        public List<JCExpression> bounds; //类型变量的上界, 可以有多个
    }
```

### 1.6 JCVariableDecl类

> **每个成员变量(Field)或局部变量(Variable)都是一个`JCVariableDecl`对象。对于方法形式参数来说，虽然与块内局部变量稍有不同，但也是局部变量。**

```java
public static class JCVariableDecl extends JCStatement implements VariableTree {
        public JCModifiers mods;
        public Name name;
        public JCExpression vartype; //变量声明的类型
        public JCExpression init;    //变量的初始化部分
        public VarSymbol sym;
}
```

### 1.7 JCMethodDecl类

> **`JCMethodDecl`类表示一个方法，包括抽象方法和非抽象方法**

```java
    public static class JCMethodDecl extends JCTree implements MethodTree {
        public JCModifiers mods;
        public Name name;
        public JCExpression restype;
        public List<JCTypeParameter> typarams;
        public List<JCVariableDecl> params;
        public List<JCExpression> thrown;
        public JCBlock body;
        public JCExpression defaultValue; // for annotation types
        public MethodSymbol sym;
    }
```

## 2. 语句

> **所有能表示语句的类都继承了`JCStatement`抽象类。**
>
> **Javac中定义了两个特殊的类`JCSkip`与`JCExpressionStatement`。`JCSkip`表示空语句，即一个单独的分号。`JCExpressionStatement`类可以将表达式转换为语句。**

```java
public static abstract class JCStatement extends JCTree implements StatementTree {
        @Override
        public JCStatement setType(Type type) {
            super.setType(type);
            return this;
        }
        @Override
        public JCStatement setPos(int pos) {
            super.setPos(pos);
            return this;
        }
}

public static class JCSkip extends JCStatement implements EmptyStatementTree {
        protected JCSkip() {
        }
        @Override public int getTag() {
            return SKIP;
        }
}

 
public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
    public JCExpression expr; //封装语句表达式
}
```

### 2.1 JCBlock类

> **除了类body体外，每对花括号"{}"括起来的块都是一个`JCBlock`对象**

```java
    public static class JCBlock extends JCStatement implements BlockTree {
        public long flags;
        public List<JCStatement> stats;
    }
```

### 2.2 JCIf类

> **if语句在词法分析的过程中要解决的一个问题就是悬空 else(dangling else)。**

```java
    public static class JCIf extends JCStatement implements IfTree {
        public JCExpression cond;
        public JCStatement thenpart; //if部分
        public JCStatement elsepart; //else部分
    }
```

### 2.3 JCWhileLoop、JCDoWhileLoop、JCForLoop、JCEnhancedForLoop类

```java
public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
        public JCExpression cond;
        public JCStatement body;
}

public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
        public JCStatement body;
        public JCExpression cond;
}

public static class JCForLoop extends JCStatement implements ForLoopTree {
        public List<JCStatement> init;
        public JCExpression cond;
        public List<JCExpressionStatement> step;
        public JCStatement body;
}

public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
        public JCVariableDecl var;
        public JCExpression expr;
        public JCStatement body;
}
```

### 2.4 JCSwitch 和 JCCase 类

```java
public static class JCSwitch extends JCStatement implements SwitchTree {
        public JCExpression selector;
        public List<JCCase> cases;
}

public static class JCCase extends JCStatement implements CaseTree {
        public JCExpression pat;
        public List<JCStatement> stats;
}
```

### 2.5 JCTry、JCCatch、JCThrow类

```java
public static class JCTry extends JCStatement implements TryTree {
        public JCBlock body;
        public List<JCCatch> catchers;
        public JCBlock finalizer;
        public List<JCTree> resources;
}

public static class JCCatch extends JCTree implements CatchTree {
        public JCVariableDecl param;
        public JCBlock body;
    
}

public static class JCThrow extends JCStatement implements ThrowTree {
        public JCExpression expr;
}
```

### 2.6 JCLabeledStatement、JCReturn、JCContinue、JCBreak类

```java
public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
        public Name label;
        public JCStatement body;
}

public static class JCReturn extends JCStatement implements ReturnTree {
        public JCExpression expr;
}

public static class JCContinue extends JCStatement implements ContinueTree {
        public Name label;
        public JCTree target;
}

public static class JCBreak extends JCStatement implements BreakTree {
        public Name label;
        public JCTree target;
}
```

### 2.7 JCSynchronized类

```java
public static class JCSynchronized extends JCStatement implements SynchronizedTree {
        public JCExpression lock;
        public JCBlock body;
}
```

### 2.8 JCAssert类

```java
public static class JCAssert extends JCStatement implements AssertTree {
        public JCExpression cond;
        public JCExpression detail;
}
```

## 3. 表达式

> **在Java中，一个复杂表达式可由基本表达式和运算符构成，所以能表示表达式的类都会继承`JCExpression`抽象类**

### 3.1 基本表达式

```java
public static abstract class JCExpression extends JCTree implements ExpressionTree {
        @Override public JCExpression setType(Type type) {
            super.setType(type);
            return this;
        }
        @Override public JCExpression setPos(int pos) {
            super.setPos(pos);
            return this;
        }
}
```

#### 3.1.1 Literal文法 JCLiteral

> **每个字面量都是一个`JCLiteral`对象**

```java
public static class JCLiteral extends JCExpression implements LiteralTree {
        public int typetag; //表示不同的字面量, 取值参才情TypeTags类
        public Object value; //保存具体的字面量
}
```

#### 3.1.2 this文法 JCIdent

```java
public static class JCIdent extends JCExpression implements IdentifierTree {
        public Name name; //"this"
        public Symbol sym;
}
```

#### 3.1.3 FieldAccess、Type.class、void.class 和 ClassName.this 文法

```java
public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
        public JCExpression selected;
        public Name name;
        public Symbol sym;
}
```

#### 3.1.4 (Expression) 文法

```java
public static class JCParens extends JCExpression implements ParenthesizedTree {
        public JCExpression expr; //保存括号内的表达式内容
}
```

#### 3.1.5 ClassInstanceCreationExpression文法

```java
public static class JCNewClass extends JCExpression implements NewClassTree {
        public JCExpression encl; //文法中的Primary
        public List<JCExpression> typeargs;
        public JCExpression clazz;
        public List<JCExpression> args;
        public JCClassDecl def;
        public Symbol constructor;
        public Type varargsElement;
        public Type constructorType;
}
```

#### 3.1.6 MethodInvocation文法

```java
 public static class JCMethodInvocation extends JCExpression implements MethodInvocationTree {
        public List<JCExpression> typeargs; //传递的实际类型参数
        public JCExpression meth;  //要调用的方法
        public List<JCExpression> args; //实际参数
        public Type varargsElement;
 }
```

#### 3.1.7 ArrayAccess文法

```java
public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
        public JCExpression indexed;
        public JCExpression index;
}
```

#### 3.1.8 ArrayCreationExpression文法

```java
public static class JCNewArray extends JCExpression implements NewArrayTree {
        public JCExpression elemtype; //元素类型
        public List<JCExpression> dims; //每个维度大小
        public List<JCExpression> elems; //初始化部分
}
```

### 3.2 含运算符的表达式

#### 3.2.1 一元表达式

```java
//一元表达式之一元运算符
public static class JCUnary extends JCExpression implements UnaryTree {
        private int opcode; //允许的取值参考JCTree类中的定义
        public JCExpression arg; //一元运算符的操作数
        public Symbol operator;
}

//一元表达式之强制类型转换
public static class JCTypeCast extends JCExpression implements TypeCastTree {
        public JCTree clazz;
        public JCExpression expr;
}
```

#### 3.2.2 二元表达式

```java
//普通运算符
public static class JCBinary extends JCExpression implements BinaryTree {
        private int opcode;
        public JCExpression lhs;
        public JCExpression rhs;
        public Symbol operator;
}

//赋值运算符 "="运算符
public static class JCAssign extends JCExpression implements AssignmentTree {
        public JCExpression lhs; //运算符左侧的操作数
        public JCExpression rhs; //运算符右侧的操作数
}

//赋值运算符 非"="运算符
public static class JCAssignOp extends JCExpression implements CompoundAssignmentTree {
        private int opcode;
        public JCExpression lhs;
        public JCExpression rhs;
        public Symbol operator;
}

//instanceof运算符
public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
        public JCExpression expr;
        public JCTree clazz;
}
```

#### 3.2.3 三元表达式

```java
//三元运算符
public static class JCConditional extends JCExpression implements ConditionalExpressionTree {
        public JCExpression cond;
        public JCExpression truepart;
        public JCExpression falsepart;
}
```

### 3.3 类型相关表达式

#### 3.3.1 基本类型

```java
public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
        public int typetag; //类型, 参考TypeTags中定义的常量
}
```

#### 3.3.2 引用类型

```java
//参数化类型使用JCTypeApply类来表示
public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
        public JCExpression clazz; //具体类型可能为JCIdent或JCFieldAccess
        public List<JCExpression> arguments; //多个实际类型参数保存到arguments
}
```

### 3.4 注解表达式

```java
public static class JCAnnotation extends JCExpression implements AnnotationTree {
        public JCTree annotationType; //注解类型
        public List<JCExpression> args; //保存多个注解参数
}
```

## 4. 生成树节点

> **创建抽象语法树中的节点专门有个工厂类`TreeMaker`，其实现了`JCTree.Factory`接口并实现了创建各个语法树节点的工厂方法。**

### 示例代码

```java
package org.gwwwwt.chapter4;

import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.code.TypeTags;
import com.sun.tools.javac.file.JavacFileManager;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.TreeMaker;
import com.sun.tools.javac.util.*;

public class TestTreeMaker {
    static Names names;
    static TreeMaker F;

    public static void main(String[] args) {
        Context context = new Context();
        JavacFileManager.preRegister(context);
        F = TreeMaker.instance(context);
        names = Names.instance(context);

        JCTree.JCModifiers mods = F.Modifiers(Flags.PUBLIC);
        JCTree.JCPrimitiveTypeTree type = F.TypeIdent(TypeTags.INT);
        Name name = names.fromString("a");
        JCTree.JCLiteral init = F.Literal(TypeTags.INT, "1");
        JCTree.JCVariableDecl result = F.VarDef(mods, name, type, init);

        JCTree.JCModifiers mods1 = F.Modifiers(Flags.PUBLIC);
        Name name1 = names.fromString("Test");
        ListBuffer<JCTree> defs = new ListBuffer<>();
        defs.append(result);

        List<JCTree.JCTypeParameter> typarams = List.nil();
        List<JCTree.JCExpression> implementing = List.nil();
        JCTree.JCClassDecl jcc = F.ClassDef(mods1, name1, typarams, null, implementing, defs.toList());

        ListBuffer<JCTree> defsx = new ListBuffer<>();
        defsx.add(jcc);
        List<JCTree.JCAnnotation> packageAnnotations = List.nil();

        JCTree.JCIdent ifr = F.Ident(names.fromString("org.gwwwwt.chapter4"));
        JCTree.JCExpression pid = ifr;
        JCTree.JCCompilationUnit topLevel = F.TopLevel(packageAnnotations, pid, defsx.toList());

        System.out.println(topLevel.toString());
    }
}
```

> **运行程序的输出结果：**
>
> ```java
> //即上面的代码的输出结果和直接定义如下的代码相同
> package org.gwwwwt.chapter4;
> 
> public class Test {
>     public int a = 1;
> }
> ```